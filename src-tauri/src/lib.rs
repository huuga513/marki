use chrono::{Datelike, TimeZone, Utc};
use fancy_regex::Regex;
use rusqlite::{params, params_from_iter, Connection, Result};
use serde::Serialize;
use sha2::{Digest, Sha256};
use std::{collections::HashMap, fs::File, io::Read};
const DB_NAME: &str = "marki.db";
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![greet, open_card_file])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

#[tauri::command]
fn greet() -> Result<(), String> {
    let conn = Connection::open(DB_NAME).map_err(|why| why.to_string())?;
    conn.execute(
        "
    CREATE TABLE IF NOT EXISTS cards (
    sha BINARY(32) PRIMARY KEY,
        -- the sha256 of the card content
    repetitions            INTEGER NOT NULL,
        -- the number of times the information has been reviewed prior to this review
    factor FLOAT NOT NULL,
        -- a floating point number (>= 1.3) generated by the last iteration of the SM-2 algorithm.
    interval INTEGER NOT NULL,
        --  indicates the number of days to wait between reviews.
    due BIGINT NOT NULL
        -- unix timestamp rounded to days
    );",
        [],
    )
    .map_err(|why| why.to_string())?;
    Ok(())
}

fn today_timestamp() -> i64 {
    let now = Utc::now();

    let year = now.year();
    let month = now.month();
    let day = now.day();

    let today_midnight = Utc.with_ymd_and_hms(year, month, day, 0, 0, 0).unwrap();

    let timestamp = today_midnight.timestamp();
    timestamp
}

type Hash = String;
#[derive(Serialize)]
struct Card {
    hash: Hash,
    front: String,
    back: String,
}

impl Card {
    fn new<S: AsRef<str>>(front: S, back: S) -> Card {
        let front = front.as_ref();
        let back = back.as_ref();
        let mut hasher = Sha256::new();
        hasher.update(front);
        hasher.update(back);
        let hash = hasher.finalize();
        let hash = hex::encode(hash);
        Card {
            hash: hash,
            front: front.to_owned(),
            back: back.to_owned(),
        }
    }
}

#[tauri::command]
/* Open a card file, returns cards should be reviewed today */
fn open_card_file(file_path: &str) -> Result<Vec<Card>, String> {
    let mut file = File::open(file_path).map_err(|why| why.to_string())?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|why| why.to_string())?;
    let contents = contents.replace("\r\n", "\n");
    let qas = extract_qa(&contents).map_err(|why| why.to_string())?;
    let cards: Vec<Card> = qas
        .into_iter()
        .map(|qa: (String, String)| Card::new(qa.0, qa.1))
        .collect();
    let cards = insert_and_fetch_db(cards)?;
    Ok(cards)
}

fn insert_and_fetch_db(cards: Vec<Card>) -> Result<Vec<Card>, String> {
    let conn = Connection::open(DB_NAME).map_err(|why| why.to_string())?;
    insert_new_cards(&conn, &cards).map_err(|_|{"Failed to insert cards.".to_string()})?;
    let cards = fetch_review_cards(&conn, cards)?;
    Ok(cards)
}

fn fetch_review_cards(
    conn: &Connection,
    cards: Vec<Card>,
) -> Result<Vec<Card>, String> {
    // 若输入卡片为空，直接返回空 Vec
    if cards.is_empty() {
        return Ok(Vec::new());
    }
    let now_timestamp = Utc::now().timestamp();

    // 1. 提取所有卡片的 sha 值
    let shas: Vec<&str> = cards.iter().map(|c| c.hash.as_str()).collect();

    // 2. 构建 SQL 查询，批量获取 sha 对应的 due 值
    let placeholders = vec!["?"; shas.len()].join(",");
    let query = format!("SELECT sha, due FROM cards WHERE sha IN ({})", placeholders);

    // 3. 执行查询并映射结果到 HashMap
    let params = params_from_iter(shas.iter().map(|s| s as &dyn rusqlite::ToSql));
    let mut stmt = conn.prepare(&query).map_err(|e| e.to_string())?;
    let rows = stmt
        .query_map(params, |row| {
            Ok((row.get::<_, String>(0)?, row.get::<_, i64>(1)?))
        })
        .map_err(|e| e.to_string())?;

    let mut due_map = HashMap::new();
    for row in rows {
        let (sha, due) = row.map_err(|e| e.to_string())?;
        due_map.insert(sha, due);
    }

    // 4. 筛选符合条件的卡片（due > today_timestamp）
    let result = cards
        .into_iter()
        .filter(|card| {
            due_map
                .get(&card.hash)
                .map(|due| *due < now_timestamp)
                .unwrap_or(false) // 若 sha 不在表中，视为不满足条件
        })
        .collect();

    Ok(result)
}

fn insert_new_cards(conn: &Connection, cards: &[Card]) -> Result<()> {

    let rep_init = 0;
    let factor_init = 2.5;
    let interval_init = 0;
    let today_timestamp = today_timestamp();

    let mut stmt = conn.prepare(
        "INSERT INTO cards (sha, repetitions, factor, interval, due)
         VALUES (?1, ?2, ?3, ?4, ?5)
         ON CONFLICT(sha) DO NOTHING"
    )?;

    for card in cards {
        stmt.execute(params![
            card.hash,        // SHA256 必须为 64 字符字符串
            rep_init,
            factor_init,
            interval_init,
            today_timestamp,
        ])?;
    }
    Ok(())
}

fn extract_qa(input: &str) -> Result<Vec<(String, String)>, Box<dyn std::error::Error>> {
    // Thanks: https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Question-answer-style
    let re = Regex::new(r"(?m)^Q: ((?:.+\n)*)\n*A: (.+(?:\n(?:^.{1,3}$|^.{4}(?<!<!--).*))*)")?;

    let mut results = Vec::new();
    for capture in re.captures_iter(input) {
        let capture = capture?;
        if let (Some(q), Some(a)) = (capture.get(1), capture.get(2)) {
            results.push((
                q.as_str().trim_end().to_string(),
                a.as_str().trim_end().to_string(),
            ));
        }
    }
    Ok(results)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_all() {
        let input = r#"
Q: How do you use this style?
A: Just like this.

Guguga. SHou

Q: cannt see me 

Q: Can the question
run over multiple lines?
A: Yes, and
So can the answer

Q: Does the answer need to be immediately after the question?


A: No, and preceding whitespace will be ignored.

Q: How is this possible?
A: The 'magic' of regular expressions!
        "#;
        for (q, a) in extract_qa(input).unwrap() {
            println!("question:{q}");
            println!("ans:{a}");
        }
    }

    #[test]
    fn test_crlf() {
        let input = "Q: How do you use this style?\r\nA: Just like this.\r\nGuguga. SHou\r\nQ: cannt see me\r\nQ: Can the question
run over multiple lines?\r\n
A: Yes, and\r\n
So can the answer

Q: Does the answer need to be immediately after the question?


A: No, and preceding whitespace will be ignored.

Q: How is this possible?
A: The 'magic' of regular expressions!
        ";
        for (q, a) in extract_qa(input).unwrap() {
            println!("question:{q}");
            println!("ans:{a}");
        }
    }
    #[test]
    fn test_single_line_qa() {
        let input = r#"Q: Question?
A: Answer"#;
        let result = extract_qa(input).unwrap();
        assert_eq!(result, vec![("Question?".into(), "Answer".into())]);
    }

    #[test]
    fn test_multi_line_qa() {
        let input = r#"Q: Line1
Line2?
A: Answer1
Answer2"#;
        let result = extract_qa(input).unwrap();
        assert_eq!(
            result,
            vec![("Line1\nLine2?".into(), "Answer1\nAnswer2".into())]
        );
    }

    #[test]
    fn test_whitespace_between_qa() {
        let input = r#"Q: Question?

A: Answer
"#;
        let result = extract_qa(input).unwrap();
        assert_eq!(result, vec![("Question?".into(), "Answer".into())]);
    }

    #[test]
    fn test_special_characters() {
        let input = r#"Q: What's this?
A: It's 'magic'"#;
        let result = extract_qa(input).unwrap();
        assert_eq!(result, vec![("What's this?".into(), "It's 'magic'".into())]);
    }

    #[test]
    fn test_multiple_qa_pairs() {
        let input = r#"Q: Q1?
A: A1

Q: Q2
has two lines
A: A2
has
three
lines"#;
        let result = extract_qa(input).unwrap();
        assert_eq!(
            result,
            vec![
                ("Q1?".into(), "A1".into()),
                ("Q2\nhas two lines".into(), "A2\nhas\nthree\nlines".into())
            ]
        );
    }
}
